package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"sort"
	"strings"
)

type OpenAPISpec struct {
	Paths map[string]interface{} `json:"paths"`
}

func main() {
	url := "https://www.mingweisamuel.com/riotapi-schema/openapi-3.0.0.min.json"
	resp, err := http.Get(url)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error fetching OpenAPI spec: %v\n", err)
		os.Exit(1)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		fmt.Fprintf(os.Stderr, "Error: received status code %d\n", resp.StatusCode)
		os.Exit(1)
	}

	// Read the response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading response body: %v\n", err)
		os.Exit(1)
	}

	// Parse the JSON
	var spec OpenAPISpec
	if err := json.Unmarshal(body, &spec); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing JSON: %v\n", err)
		os.Exit(1)
	}

	// Extract all path patterns
	paths := make([]string, 0, len(spec.Paths))
	for path := range spec.Paths {
		paths = append(paths, path)
	}

	// Sort paths for consistent output
	sort.Strings(paths)

	// Generate Go code
	fmt.Println("// Code generated by scripts/genrate_path_patterns.go")
	fmt.Println("// Based on the Riot API OpenAPI spec: https://www.mingweisamuel.com/riotapi-schema/openapi-3.0.0.min.json")
	fmt.Println("// DO NOT EDIT IF YOU DON'T KNOW WHAT YOU'RE DOING.")
	fmt.Println()
	fmt.Println("package router")
	fmt.Println()
	fmt.Println("var PathPatterns = []string{")
	for _, path := range paths {
		// Escape backticks and backslashes in the path string
		escaped := strings.ReplaceAll(path, "`", "` + \"`\" + `")
		escaped = strings.ReplaceAll(escaped, "\\", "\\\\")
		fmt.Printf("\t%q,\n", escaped)
	}
	fmt.Println("}")
}
